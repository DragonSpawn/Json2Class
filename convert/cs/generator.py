from convert.base.generator import BaseGenerator
from convert.base.parsedobject import *
import datetime


class Generator(BaseGenerator):
    def _generate_default_constructor(self):
        constructor = ("        public {0}()\n"
                       "        {{\n").format(_capitalize(self.data.name))

        for member in self.data.data:
            if member.type == ParsedObjectType.Array:
                constructor += "            {0} = {1}();\n".format(_capitalize(member.name), _get_member_initialization_string(member, ""))
            elif member.type == ParsedObjectType.String:
                constructor += "            {0} = string.Empty;\n".format(_capitalize(member.name))
        constructor += "        }\n\n"
        return constructor

    def _generate_member_access(self):
        properties = ""
        for member in self.data.data:
            properties += _member_declaration(member)
        return properties

    def file_name(self, name):
        return name[0].upper() + name[1:] + ".cs"

    def _generate_header(self):
        result = ""
        for member in self.data.data:
            if member.type == ParsedObjectType.Array:
                result += "using System.Collections.Generic;\n"
                break

        date_str = "Date: {0}".format(datetime.date.today())
        date_str = date_str.ljust(80)
        for factory in self.factories:
            result += factory.generate_import()
        result += ("\n/////////////////////////////////////////////////////////////////////////////////////\n"
                   "/* This file is generated by Json2Class (https://github.com/DragonSpawn/Json2Class)*/\n"
                   "/* Modifications to this file will be lost the next time you run the tool.         */\n"
                   "/* {2}*/\n"
                   "/////////////////////////////////////////////////////////////////////////////////////\n\n"
                   "namespace {0}\n"
                   "{{\n"
                   "    public class {1}\n"
                   "    {{\n").format(self.namespace, _capitalize(self.data.name), date_str)
        return result

    def _generate_footer(self):
        return ("    }\n"
                "}\n")


def _get_member_initialization_string(member, json_container):
    if member.type == ParsedObjectType.Object:
        return "new {0}({1})".format(_capitalize(member.name), json_container)
    if member.type == ParsedObjectType.Array:
        return "new {0}".format( _get_type_name(member))


def _member_declaration(member):
    return "        public {0} {1} {{get; set;}}\n".format(_get_type_name(member), _capitalize(member.name))

def _capitalize(obj):
    """
    Returns the object name with the first letter capitalized (all other untouched).
    :param obj:
    :return:
    """
    if obj.__len__() < 2:
        return obj
    if obj == "string" or obj == "float" or obj == "int":
        return obj
    return obj[0].upper() + obj[1:]


def _get_type_name(member):
    """
    If a ParsedClass is supplied then it returns the object name with a captialized first letter (myClass => MyClass)
    For ParsedMember it returns the type of the member (myString => string)
    :type member: ParsedMember
    :param obj:
    :return:
    """
    if member.type == ParsedObjectType.String or member.type == ParsedObjectType.Int or member.type == ParsedObjectType.Float or member.type == ParsedObjectType.Bool:
        return member.type.name.lower()
    elif member.type == ParsedObjectType.Array:
        return "List<{0}>".format(_get_type_name(member.data[0]))
    else:
        return _capitalize(member.name)